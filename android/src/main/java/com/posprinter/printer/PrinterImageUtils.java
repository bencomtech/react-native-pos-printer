package com.posprinter.printer;

import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Color;
import android.util.Log;

import java.util.ArrayList;
import java.util.List;

public class PrinterImageUtils {
  public static final byte[] UNICODE_TEXT = new byte[]{0x23, 0x23, 0x23,
    0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23,
    0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23,
    0x23, 0x23, 0x23};

  private static String hexStr = "0123456789ABCDEF";
  private static String[] binaryArray = {"0000", "0001", "0010", "0011",
    "0100", "0101", "0110", "0111", "1000", "1001", "1010", "1011",
    "1100", "1101", "1110", "1111"};

  public static byte[] decodeBitmap(Bitmap bmp) {
    int bmpWidth = bmp.getWidth();
    int bmpHeight = bmp.getHeight();
    List<String> list = new ArrayList<String>(); //binaryString list
    StringBuffer sb;
    int bitLen = bmpWidth / 8;
    int zeroCount = bmpWidth % 8;
    String zeroStr = "";

    if (zeroCount > 0) {
      bitLen = bmpWidth / 8 + 1;

      for (int i = 0; i < (8 - zeroCount); i++) {
        zeroStr = zeroStr + "0";
      }
    }

    for (int i = 0; i < bmpHeight; i++) {
      sb = new StringBuffer();

      for (int j = 0; j < bmpWidth; j++) {
        int color = bmp.getPixel(j, i);
        int r = (color >> 16) & 0xff;
        int g = (color >> 8) & 0xff;
        int b = color & 0xff;

        // if color close to whiteï¼Œbit='0', else bit='1'
        if (r > 160 && g > 160 && b > 160)
          sb.append("0");
        else
          sb.append("1");
      }

      if (zeroCount > 0) {
        sb.append(zeroStr);
      }

      list.add(sb.toString());
    }

    List<String> bmpHexList = binaryListToHexStringList(list);
    String commandHexString = "1D763000";
    String widthHexString = Integer
      .toHexString(bmpWidth % 8 == 0 ? bmpWidth / 8
        : (bmpWidth / 8 + 1));

    if (widthHexString.length() > 2) {
      Log.e("decodeBitmap error", " width is too large");
      return null;
    } else if (widthHexString.length() == 1) {
      widthHexString = "0" + widthHexString;
    }

    widthHexString = widthHexString + "00";
    String heightHexString = Integer.toHexString(bmpHeight);

    if (heightHexString.length() > 2) {
      Log.e("decodeBitmap error", " height is too large");
      return null;
    } else if (heightHexString.length() == 1) {
      heightHexString = "0" + heightHexString;
    }

    heightHexString = heightHexString + "00";
    List<String> commandList = new ArrayList<String>();
    commandList.add(commandHexString + widthHexString + heightHexString);
    commandList.addAll(bmpHexList);

    return hexList2Byte(commandList);
  }

  public static List<String> binaryListToHexStringList(List<String> list) {
    List<String> hexList = new ArrayList<String>();

    for (String binaryStr : list) {
      StringBuffer sb = new StringBuffer();

      for (int i = 0; i < binaryStr.length(); i += 8) {
        String str = binaryStr.substring(i, i + 8);
        String hexString = myBinaryStrToHexString(str);
        sb.append(hexString);
      }

      hexList.add(sb.toString());
    }

    return hexList;
  }

  public static String myBinaryStrToHexString(String binaryStr) {
    String hex = "";
    String f4 = binaryStr.substring(0, 4);
    String b4 = binaryStr.substring(4, 8);

    for (int i = 0; i < binaryArray.length; i++) {
      if (f4.equals(binaryArray[i]))
        hex += hexStr.substring(i, i + 1);
    }

    for (int i = 0; i < binaryArray.length; i++) {
      if (b4.equals(binaryArray[i]))
        hex += hexStr.substring(i, i + 1);
    }

    return hex;
  }

  public static byte[] hexList2Byte(List<String> list) {
    List<byte[]> commandList = new ArrayList<byte[]>();

    for (String hexStr : list) {
      commandList.add(hexStringToBytes(hexStr));
    }

    byte[] bytes = sysCopy(commandList);

    return bytes;
  }

  public static byte[] hexStringToBytes(String hexString) {
    if (hexString == null || hexString.equals("")) {
      return null;
    }

    hexString = hexString.toUpperCase();

    int length = hexString.length() / 2;
    char[] hexChars = hexString.toCharArray();
    byte[] d = new byte[length];

    for (int i = 0; i < length; i++) {
      int pos = i * 2;

      d[i] = (byte) (charToByte(hexChars[pos]) << 4 | charToByte(hexChars[pos + 1]));
    }

    return d;
  }

  public static byte[] sysCopy(List<byte[]> srcArrays) {
    int len = 0;

    for (byte[] srcArray : srcArrays) {
      len += srcArray.length;
    }

    byte[] destArray = new byte[len];
    int destLen = 0;

    for (byte[] srcArray : srcArrays) {
      System.arraycopy(srcArray, 0, destArray, destLen, srcArray.length);
      destLen += srcArray.length;
    }

    return destArray;
  }

  private static byte charToByte(char c) {
    return (byte) "0123456789ABCDEF".indexOf(c);
  }

  public static Bitmap addPadding(Bitmap Src, int paddingX, int paddingY) {
    Bitmap outputimage = Bitmap.createBitmap(Src.getWidth() + paddingX, Src.getHeight() + paddingY, Bitmap.Config.ARGB_8888);
    Canvas can = new Canvas(outputimage);
    can.drawARGB(255, 255, 255, 255); //This represents White color
    can.drawBitmap(Src, paddingX, paddingY, null);

    return outputimage;
  }

  public static Bitmap convertToBlackAndWhiteImage(Bitmap src) {
    int width = src.getWidth();
    int height = src.getHeight();
    // create output bitmap
    Bitmap bmOut = Bitmap.createBitmap(width, height, src.getConfig());
    // color information
    int A, R, G, B;
    int pixel;

    for (int x = 0; x < width; ++x) {
      for (int y = 0; y < height; ++y) {
        // get pixel color
        pixel = src.getPixel(x, y);
        A = Color.alpha(pixel);
        R = Color.red(pixel);
        G = Color.green(pixel);
        B = Color.blue(pixel);

        int gray = (int) (0.2989 * R + 0.5870 * G + 0.1140 * B);
        // use 128 as threshold, above -> white, below -> black
        if (gray > 128) {
          gray = 255;
        } else {
          gray = 0;
        }
        // set new pixel color to output bitmap
        bmOut.setPixel(x, y, Color.argb(A, gray, gray, gray));
      }
    }

    return bmOut;
  }
}
